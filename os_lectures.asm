;OS
;;;Полезные команды bash:
можно строить ветвления:
false && echo success || echo not success
значение - код возврата
;Условие:
if ... fi;
echo [os] [is] - вывод в *стандартный*os поток вывода
>, < перенаправление потока куда-то
;cat - посмотреть содержимое файла на стандартном выводе
| - pipe
оператор перенаправления в другую команду
grep - отдельная утилита печатает строки, удовл шаблону

touch - изменяет файл
;cmake генерирует makefile. Изучим их:
Позволяет составлять "дерево" зависимостей.
Перевызывает команды терминала OS, под которую создается makefile.
(в Linux - команды bash).
Состоит из меток (all: ,test:) целей. Они создают дерево зависимостей.
В make передаем аргумент - вершинку - цель. Он вызывает все поддерево, если нужно.
Струтктура:
	all: test
	clean:
		rm tes //<- здесь обязательно нужен tab!!!
			...
Есть странные переменные:
$@ - имя текущей собираемой цели.
$^  список всех зависимостей этой цели.
Исользуются переменные
$(CC) ;c compiler
$(CFLAGS) ;cflags
;Вернемся к bash
Очень плохо относится к пробелам, так как парсит по ним.
Можно создавать переменные bash;
B=4;
echo $B;
;Можно создавать функции
function f(){echo a; echo b; }
;Перменная PATH
список директорий для поиска бинарных файлов.
./exec
Потому что текущей директории нет в PATH
;Скрипты на bashучшк
То же самое, что и из терминала, только записанное в файле
Как получать аргументы из скрипта?
$1 $2 $3 ...
$* - конкатенация всех аргументов через пробел
$@ - подставь все аргументы
$# - количество переданных аргументов
Как запустить?
Есть 9 битиков, котоыре говоярт о том, что можно сделать с файлом.
chmod +x - изменить права на файл, сделать executable
;strace
!$ - посл аргумент посл команды

;;Дз:
;Hello, World! на C
Из двух файлов
в одном мэйн, в другом принт.
Собирать с помощью make.
